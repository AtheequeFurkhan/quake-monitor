package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

// USGS API Endpoint (All earthquakes in the past hour)
const API_URL = "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson"

// Structs for parsing GeoJSON
type FeatureCollection struct {
	Metadata Metadata  `json:"metadata"`
	Features []Feature `json:"features"`
}

type Metadata struct {
	Generated int64  `json:"generated"`
	Url       string `json:"url"`
	Title     string `json:"title"`
	Count     int    `json:"count"`
}

type Feature struct {
	Properties Properties `json:"properties"`
	Id         string     `json:"id"`
}

type Properties struct {
	Mag   float64 `json:"mag"`
	Place string  `json:"place"`
	Time  int64   `json:"time"`
	Url   string  `json:"url"`
	Type  string  `json:"type"`
}

func main() {
	// 1. Fetch Data
	data, err := fetchEarthquakeData()
	if err != nil {
		log.Fatalf("Error fetching data: %v", err)
	}

	// 2. Generate Markdown Content
	markdown := generateMarkdown(data)

	// 3. Write to README.md
	err = os.WriteFile("README.md", []byte(markdown), 0644)
	if err != nil {
		log.Fatalf("Error writing README: %v", err)
	}

	fmt.Println("README.md updated successfully.")
}

func fetchEarthquakeData() (*FeatureCollection, error) {
	client := http.Client{
		Timeout: 10 * time.Second,
	}

	resp, err := client.Get(API_URL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("API returned status: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var collection FeatureCollection
	if err := json.Unmarshal(body, &collection); err != nil {
		return nil, err
	}

	return &collection, nil
}

func generateMarkdown(data *FeatureCollection) string {
	now := time.Now().UTC().Format(time.RFC1123)
	
	// Determine Status Color based on count
	statusColor := "green"
	if data.Metadata.Count > 10 {
		statusColor = "orange"
	}
	if data.Metadata.Count > 20 {
		statusColor = "red"
	}

	var sb strings.Builder

	// Header & Badges
	sb.WriteString("# ðŸŒ Global Seismic Activity Monitor\n\n")
	sb.WriteString("This repository automatically tracks earthquakes occurring worldwide in the last hour.\n\n")
	
	sb.WriteString(fmt.Sprintf("![Last Updated](https://img.shields.io/badge/Last%%20Updated-%s-blue)\n", strings.ReplaceAll(now, " ", "%20")))
	sb.WriteString(fmt.Sprintf("![Status](https://img.shields.io/badge/Seismic%%20Status-%s-%s)\n", "Active", statusColor))
	sb.WriteString("![Source](https://img.shields.io/badge/Data%%20Source-USGS-green)\n\n")

	// Statistics
	sb.WriteString("## ðŸ“Š Current Statistics (Last Hour)\n")
	sb.WriteString(fmt.Sprintf("- **Total Earthquakes:** %d\n", data.Metadata.Count))
	sb.WriteString(fmt.Sprintf("- **Source:** [USGS GeoJSON Feed](%s)\n\n", data.Metadata.Url))

	// Table of Earthquakes
	sb.WriteString("## ðŸŒ‹ Recent Activity\n")
	if len(data.Features) == 0 {
		sb.WriteString("_No earthquakes recorded in the last hour._\n")
	} else {
		sb.WriteString("| Mag | Location | Time (UTC) | Details |\n")
		sb.WriteString("|:---:|:---|:---|:---:|\n")

		for _, f := range data.Features {
			// Formatting Time
			t := time.Unix(f.Properties.Time/1000, 0).UTC().Format("15:04:05")
			
			// Formatting Magnitude Indicator
			magIcon := "ðŸŸ¢"
			if f.Properties.Mag >= 4.5 {
				magIcon = "ðŸ”´"
			} else if f.Properties.Mag >= 2.5 {
				magIcon = "ðŸŸ "
			}

			row := fmt.Sprintf("| %s %.1f | %s | %s | [View](%s) |\n", 
				magIcon, f.Properties.Mag, f.Properties.Place, t, f.Properties.Url)
			sb.WriteString(row)
		}
	}

	sb.WriteString("\n---\n")
	sb.WriteString(fmt.Sprintf("\n*This report was auto-generated by GitHub Actions using Go.* \n"))
	
	return sb.String()
}